
这个 PR（#9209）的核心是：避免在 shim 的 create 处理逻辑中发生潜在的死锁。

⸻

一句话总结：

修复了 containerd-shim-runc-v2 中在容器创建 (Create) 阶段可能出现的 死锁问题，通过重新组织 task cleanup 的调用顺序，确保不会在持有锁时递归调用其他锁。

⸻

为什么要改？

这个问题的根源是：在执行 Create 操作时，如果中途发生错误（比如 OCI 创建失败），shim 会调用 task.Delete(ctx) 清理任务。而 Delete 内部也会尝试获取和 Create 同一个 task.mu 锁，导致死锁。

这是一个经典的「在持锁状态下调用可能再拿锁的方法」的问题。

⸻

主要改动点：

文件路径：
runtime/v2/runc/task.go

改动内容：
	•	将原先直接在 Create 出错时调用的 t.Delete(ctx) 拆分成两个阶段：
	1.	先在持锁状态下进行清理标记。
	2.	释放锁后 再调用 t.Delete(ctx) 执行任务删除。

示例伪代码对比（简化）：

// before: 错误发生时立即调用 Delete，可能死锁
t.mu.Lock()
err := createContainer()
if err != nil {
    t.Delete(ctx)  // ⚠️ 这里再次试图拿锁
}
t.mu.Unlock()

// after: 改为 defer 后清理，且先释放锁
t.mu.Lock()
err := createContainer()
t.mu.Unlock()
if err != nil {
    t.Delete(ctx)  // ✅ 此时不会死锁
}



⸻

是否值得深入看？

值得。原因如下：
	1.	这个 PR 涉及到 容器生命周期中最关键的阶段：创建（Create）。
	2.	它展示了 Go 并发编程中极容易出现的 锁顺序问题和死锁陷阱。
	3.	有助于你构建 shim 层的容器生命周期的稳定性意识。

⸻

需要我帮你画出和 shim Create -> Delete 之间锁交互流程图吗？或者你想直接跟我一起走读 task.go 的关键函数结构？
